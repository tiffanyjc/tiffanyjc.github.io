"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createRenderer: () => createRenderer,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_unist_util_visit = require("unist-util-visit");
var import_expressive_code = require("expressive-code");
var import_hast_util_to_html = require("hast-util-to-html");
__reExport(src_exports, require("expressive-code"), module.exports);
async function createRenderer(options = {}) {
  const deprecatedOptions = options;
  if (deprecatedOptions.theme && !options.themes) {
    options.themes = Array.isArray(deprecatedOptions.theme) ? deprecatedOptions.theme : [deprecatedOptions.theme];
    delete deprecatedOptions.theme;
  }
  const { themes, ...ecOptions } = options;
  const loadedThemes = themes && await Promise.all(
    (Array.isArray(themes) ? themes : [themes]).map(async (theme) => {
      const mustLoadTheme = theme !== void 0 && !(theme instanceof import_expressive_code.ExpressiveCodeTheme);
      const optLoadedTheme = mustLoadTheme ? new import_expressive_code.ExpressiveCodeTheme(typeof theme === "string" ? await (0, import_expressive_code.loadShikiTheme)(theme) : theme) : theme;
      return optLoadedTheme;
    })
  );
  const ec = new import_expressive_code.ExpressiveCode({
    themes: loadedThemes,
    ...ecOptions
  });
  const baseStyles = await ec.getBaseStyles();
  const themeStyles = await ec.getThemeStyles();
  const jsModules = await ec.getJsModules();
  return {
    ec,
    baseStyles,
    themeStyles,
    jsModules
  };
}
var remarkExpressiveCode = (...settings) => {
  const options = settings[0] ?? {};
  const { tabWidth = 2, getBlockLocale, customCreateRenderer, customCreateBlock } = options;
  let asyncRenderer;
  const renderBlockToHtml = async ({
    codeBlock,
    renderer,
    addedStyles,
    addedJsModules
  }) => {
    const { ec, baseStyles, themeStyles, jsModules } = renderer;
    const { renderedGroupAst, styles } = await ec.render(codeBlock);
    const extraElements = [];
    const stylesToPrepend = [];
    if (baseStyles && !addedStyles.has(baseStyles)) {
      addedStyles.add(baseStyles);
      stylesToPrepend.push(baseStyles);
    }
    if (themeStyles && !addedStyles.has(themeStyles)) {
      addedStyles.add(themeStyles);
      stylesToPrepend.push(themeStyles);
    }
    for (const style of styles) {
      if (addedStyles.has(style))
        continue;
      addedStyles.add(style);
      stylesToPrepend.push(style);
    }
    if (stylesToPrepend.length) {
      extraElements.push({
        type: "element",
        tagName: "style",
        children: [{ type: "text", value: [...stylesToPrepend].join("") }]
      });
    }
    jsModules.forEach((moduleCode) => {
      if (addedJsModules.has(moduleCode))
        return;
      addedJsModules.add(moduleCode);
      extraElements.push({
        type: "element",
        tagName: "script",
        properties: { type: "module" },
        children: [{ type: "text", value: moduleCode }]
      });
    });
    renderedGroupAst.children.unshift(...extraElements);
    const htmlContent = (0, import_hast_util_to_html.toHtml)(renderedGroupAst);
    return htmlContent;
  };
  const transformer = async (tree, file) => {
    const nodesToProcess = [];
    (0, import_unist_util_visit.visit)(tree, "code", (code, index, parent) => {
      if (index === null || parent === null)
        return;
      nodesToProcess.push([parent, code]);
    });
    if (nodesToProcess.length === 0)
      return;
    if (asyncRenderer === void 0) {
      asyncRenderer = (customCreateRenderer ?? createRenderer)(options);
    }
    const renderer = await asyncRenderer;
    const addedStyles = /* @__PURE__ */ new Set();
    const addedJsModules = /* @__PURE__ */ new Set();
    for (let groupIndex = 0; groupIndex < nodesToProcess.length; groupIndex++) {
      const [parent, code] = nodesToProcess[groupIndex];
      let normalizedCode = code.value;
      if (tabWidth > 0)
        normalizedCode = normalizedCode.replace(/\t/g, " ".repeat(tabWidth));
      const input = {
        code: normalizedCode,
        language: code.lang || "",
        meta: code.meta || "",
        parentDocument: {
          sourceFilePath: file.path,
          documentRoot: tree,
          positionInDocument: {
            groupIndex,
            totalGroups: nodesToProcess.length
          }
        }
      };
      if (getBlockLocale) {
        input.locale = await getBlockLocale({ input, file });
      }
      const codeBlock = customCreateBlock ? await customCreateBlock({ input, file }) : new import_expressive_code.ExpressiveCodeBlock(input);
      const blockHtml = await renderBlockToHtml({ codeBlock, renderer, addedStyles, addedJsModules });
      const html = {
        type: "html",
        value: blockHtml
      };
      parent.children.splice(parent.children.indexOf(code), 1, html);
    }
  };
  return transformer;
};
var src_default = remarkExpressiveCode;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createRenderer,
  ...require("expressive-code")
});
//# sourceMappingURL=index.cjs.map