{"version":3,"sources":["../src/index.ts","../src/ec-config.ts","../src/renderer.ts","../src/astro-config.ts","../src/vite-plugin.ts"],"sourcesContent":["import type { AstroIntegration } from 'astro'\nimport type { RemarkExpressiveCodeOptions } from 'remark-expressive-code'\nimport remarkExpressiveCode from 'remark-expressive-code'\nimport { ConfigSetupHookArgs, PartialAstroConfig } from './astro-config'\nimport { AstroExpressiveCodeOptions, CustomConfigPreprocessors, ConfigPreprocessorFn, getSupportedEcConfigFilePaths, loadEcConfigFile } from './ec-config'\nimport { createAstroRenderer } from './renderer'\nimport { vitePluginAstroExpressiveCode } from './vite-plugin'\n\nexport * from 'remark-expressive-code'\n\nexport type { AstroExpressiveCodeOptions, PartialAstroConfig, CustomConfigPreprocessors, ConfigPreprocessorFn }\nexport * from './renderer'\n\n/**\n * Astro integration that adds Expressive Code support to code blocks in Markdown & MDX documents.\n */\nexport function astroExpressiveCode(integrationOptions: AstroExpressiveCodeOptions = {}) {\n\tconst integration = {\n\t\tname: 'astro-expressive-code',\n\t\thooks: {\n\t\t\t'astro:config:setup': async (args: unknown) => {\n\t\t\t\tconst { config: astroConfig, updateConfig, injectRoute, logger, addWatchFile } = args as ConfigSetupHookArgs\n\n\t\t\t\t// Validate Astro configuration\n\t\t\t\tconst ownPosition = astroConfig.integrations.findIndex((integration) => integration.name === 'astro-expressive-code')\n\t\t\t\tconst mdxPosition = astroConfig.integrations.findIndex((integration) => integration.name === '@astrojs/mdx')\n\t\t\t\tif (ownPosition > -1 && mdxPosition > -1 && mdxPosition < ownPosition) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect integration order: To allow code blocks on MDX pages to use\n\t\t\t\t\t\tastro-expressive-code, please move astroExpressiveCode() before mdx()\n\t\t\t\t\t\tin the \"integrations\" array of your Astro config file.`.replace(/\\s+/g, ' ')\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// Watch all supported config file names for changes\n\t\t\t\tgetSupportedEcConfigFilePaths(astroConfig.root).forEach((filePath) => addWatchFile(filePath))\n\n\t\t\t\t// Merge the given options with the ones from a potential EC config file\n\t\t\t\tconst ecConfigFileOptions = await loadEcConfigFile(astroConfig.root)\n\t\t\t\tconst mergedOptions: AstroExpressiveCodeOptions = { ...ecConfigFileOptions, ...integrationOptions }\n\n\t\t\t\t// Warn if the user is both using an EC config file and passing options directly\n\t\t\t\tconst forwardedIntegrationOptions = { ...integrationOptions }\n\t\t\t\tdelete forwardedIntegrationOptions.customConfigPreprocessors\n\t\t\t\tif (Object.keys(ecConfigFileOptions).length > 0 && Object.keys(forwardedIntegrationOptions).length > 0) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Your project includes an Expressive Code config file (\"ec.config.mjs\"),\n\t\t\t\t\t\tbut your Astro config file also contains Expressive Code options.\n\t\t\t\t\t\tTo avoid unexpected results from merging multiple config sources,\n\t\t\t\t\t\tmove all Expressive Code options into its config file.\n\t\t\t\t\t\tFound options: ${Object.keys(forwardedIntegrationOptions).join(', ')}`.replace(/\\s+/g, ' ')\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// Preprocess the merged config if custom preprocessors were provided\n\t\t\t\tconst processedEcConfig = (await mergedOptions.customConfigPreprocessors?.preprocessAstroIntegrationConfig({ ecConfig: mergedOptions, astroConfig })) || mergedOptions\n\n\t\t\t\t// Prepare config to pass to the remark integration\n\t\t\t\tconst { customCreateAstroRenderer } = processedEcConfig\n\t\t\t\tdelete processedEcConfig.customCreateAstroRenderer\n\t\t\t\tdelete processedEcConfig.customConfigPreprocessors\n\n\t\t\t\tconst { hashedStyles, hashedScripts, ...renderer } = await (customCreateAstroRenderer ?? createAstroRenderer)({ astroConfig, ecConfig: processedEcConfig, logger })\n\n\t\t\t\t// Inject route handlers that provide access to the extracted styles & scripts\n\t\t\t\thashedStyles.forEach(([hashedRoute]) => {\n\t\t\t\t\tconst entrypoint = new URL('../routes/styles.ts', import.meta.url).href\n\t\t\t\t\tinjectRoute({\n\t\t\t\t\t\tpattern: hashedRoute,\n\t\t\t\t\t\tentrypoint,\n\t\t\t\t\t\tprerender: true,\n\t\t\t\t\t\t// @ts-expect-error: Also provide the old property name used in Astro 3\n\t\t\t\t\t\tentryPoint: entrypoint,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\thashedScripts.forEach(([hashedRoute]) => {\n\t\t\t\t\tconst entrypoint = new URL('../routes/scripts.ts', import.meta.url).href\n\t\t\t\t\tinjectRoute({\n\t\t\t\t\t\tpattern: hashedRoute,\n\t\t\t\t\t\tentrypoint,\n\t\t\t\t\t\tprerender: true,\n\t\t\t\t\t\t// @ts-expect-error: Also provide the old property name used in Astro 3\n\t\t\t\t\t\tentryPoint: entrypoint,\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tconst remarkExpressiveCodeOptions: RemarkExpressiveCodeOptions = {\n\t\t\t\t\t// Even though we have created a custom renderer, some options are used\n\t\t\t\t\t// by the remark integration itself (e.g. `tabWidth`, `getBlockLocale`),\n\t\t\t\t\t// so we pass all of them through just to be safe\n\t\t\t\t\t...processedEcConfig,\n\t\t\t\t\t// Pass our custom renderer to the remark integration\n\t\t\t\t\tcustomCreateRenderer: () => renderer,\n\t\t\t\t}\n\n\t\t\t\tupdateConfig({\n\t\t\t\t\tvite: {\n\t\t\t\t\t\tplugins: [\n\t\t\t\t\t\t\t// Add the Vite plugin that provides all data for the route handler\n\t\t\t\t\t\t\tvitePluginAstroExpressiveCode({\n\t\t\t\t\t\t\t\tstyles: hashedStyles,\n\t\t\t\t\t\t\t\tscripts: hashedScripts,\n\t\t\t\t\t\t\t\tecIntegrationOptions: integrationOptions,\n\t\t\t\t\t\t\t\tastroConfig,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tmarkdown: {\n\t\t\t\t\t\tsyntaxHighlight: false,\n\t\t\t\t\t\tremarkPlugins: [[remarkExpressiveCode, remarkExpressiveCodeOptions]],\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t} satisfies AstroIntegration\n\n\treturn integration\n}\n\n/**\n * A utility function that helps you define an Expressive Code configuration object. It is meant\n * to be used inside the optional config file `ec.config.mjs` located in the root directory\n * of your Astro project, and its return value to be exported as the default export.\n *\n * Expressive Code will automatically detect this file and use the exported configuration object\n * to override its own default settings.\n *\n * Using this function is recommended, but not required. It just passes through the given object,\n * but it also provides type information for your editor's auto-completion and type checking.\n *\n * @example\n * ```js\n * // ec.config.mjs\n * import { defineEcConfig } from 'astro-expressive-code'\n *\n * export default defineEcConfig({\n *   themes: ['dracula', 'github-light'],\n *   styleOverrides: {\n *     borderRadius: '0.5rem',\n *   },\n * })\n * ```\n */\nexport function defineEcConfig(config: AstroExpressiveCodeOptions) {\n\treturn config\n}\n\n// Provide a default export for convenience and `astro add astro-expressive-code` compatibility\nexport default astroExpressiveCode\n","import { existsSync } from 'node:fs'\nimport { resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport type { RemarkExpressiveCodeOptions } from 'remark-expressive-code'\nimport type { PartialAstroConfig } from './astro-config'\nimport type { AstroExpressiveCodeRenderer, CreateAstroRendererArgs } from './renderer'\n\nexport type AstroExpressiveCodeOptions = RemarkExpressiveCodeOptions & {\n\t/**\n\t * Determines if the styles required to display code blocks should be emitted into a separate\n\t * CSS file rather than being inlined into the rendered HTML of the first code block per page.\n\t *\n\t * This is recommended for sites containing multiple pages with code blocks, as it will reduce\n\t * the overall footprint of the site when navigating between pages.\n\t *\n\t * The generated URL is located inside Astro's assets directory and includes a content hash\n\t * so it can be cached indefinitely by browsers. If you are using the default values for the\n\t * Astro config options `base`, `build.assets`, `build.assetsPrefix`, the resulting URL\n\t * will be `/_astro/ec.{hash}.css`.\n\t *\n\t * **Important**: To actually benefit from caching, please ensure that your hosting provider\n\t * serves the contents of the assets directory as immutable files with a long cache lifetime,\n\t * e.g. `Cache-Control: public,max-age=31536000,immutable`.\n\t *\n\t * @default true\n\t */\n\temitExternalStylesheet?: boolean | undefined\n\t/**\n\t * This advanced option allows you to influence the rendering process by creating\n\t * your own `AstroExpressiveCodeRenderer` or processing the base styles and JS modules\n\t * added to every page.\n\t *\n\t * The return value will be cached and used for all code blocks on the site.\n\t */\n\tcustomCreateAstroRenderer?: ((args: CreateAstroRendererArgs) => Promise<AstroExpressiveCodeRenderer> | AstroExpressiveCodeRenderer) | undefined\n\t/**\n\t * This advanced option allows you to preprocess the Expressive Code configuration\n\t * before it is used by the Astro integration or its exported `<Code>` component.\n\t *\n\t * For example, Starlight uses this option to provide different default settings\n\t * and additional theme options.\n\t */\n\tcustomConfigPreprocessors?: CustomConfigPreprocessors | undefined\n}\n\nexport type CustomConfigPreprocessors = {\n\t/**\n\t * To perform preprocessing on the Expressive Code configuration before it is used\n\t * by the Astro integration, set this property to a function. It will be called with\n\t * an object argument that contains the following properties:\n\t * - `ecConfig`: an Expressive Code config object merged from the optional EC config file\n\t *   `ec.config.mjs` and any options passed directly to the integration\n\t * - `astroConfig`: an object containing commonly used settings from the Astro configuration\n\t *\n\t * The return value must be a valid Expressive Code configuration object.\n\t */\n\tpreprocessAstroIntegrationConfig: ConfigPreprocessorFn\n\t/**\n\t * If you set `preprocessAstroIntegrationConfig` to a function, you must also set this property\n\t * to the JS source code of a Vite virtual module that exports the same function as its\n\t * default export.\n\t *\n\t * This is necessary to allow the `<Code>` component to access the same preprocessed config\n\t * as the Astro integration. The Astro integration cannot share the function directly with\n\t * the `<Code>` component because it runs in a separate Vite instance.\n\t */\n\tpreprocessComponentConfig: string\n}\n\nexport type ConfigPreprocessorFn = (args: { ecConfig: unknown; astroConfig: PartialAstroConfig }) => Promise<AstroExpressiveCodeOptions> | AstroExpressiveCodeOptions\n\n/**\n * Returns an array of supported absolute EC config file paths in the Astro project root.\n */\nexport function getSupportedEcConfigFilePaths(projectRootUrl: URL | string) {\n\tconst projectRootPath = fileURLToPath(projectRootUrl)\n\treturn [resolve(projectRootPath, 'ec.config.mjs')]\n}\n\n/**\n * Returns the first existing config file path of {@link getSupportedEcConfigFilePaths}.\n */\nexport function findEcConfigFilePath(projectRootUrl: URL | string) {\n\tconst ecConfigFile = getSupportedEcConfigFilePaths(projectRootUrl).find((fileName) => existsSync(fileName))\n\treturn ecConfigFile\n}\n\n/**\n * Attempts to import an EC config file in the Astro project root and returns its default export.\n *\n * If no config file is found, an empty object is returned.\n */\nexport async function loadEcConfigFile(projectRootUrl: URL | string): Promise<AstroExpressiveCodeOptions> {\n\tconst pathsToTry = [\n\t\t// This path works in most scenarios, but not when the integration is processed by Vite\n\t\t// due to a Vite bug affecting import URLs using the \"file:\" protocol\n\t\tnew URL(`./ec.config.mjs?t=${Date.now()}`, projectRootUrl).href,\n\t]\n\t// Detect if the integration is processed by Vite\n\tif (import.meta.env?.BASE_URL?.length) {\n\t\t// Add a fallback path starting with \"/\", which Vite treats as relative to the project root\n\t\tpathsToTry.push(`/ec.config.mjs?t=${Date.now()}`)\n\t}\n\tfor (const path of pathsToTry) {\n\t\ttry {\n\t\t\tconst module = (await import(/* @vite-ignore */ path)) as { default: AstroExpressiveCodeOptions }\n\t\t\tif (!module.default) {\n\t\t\t\tthrow new Error(`Missing or invalid default export. Please export your Expressive Code config object as the default export.`)\n\t\t\t}\n\t\t\treturn module.default\n\t\t} catch (error) {\n\t\t\t/* c8 ignore next */\n\t\t\tconst msg = error instanceof Error ? error.message : (error as string)\n\t\t\tconst code = (error as { code?: string | undefined }).code\n\t\t\t// If the config file was not found, continue with the next path (if any)\n\t\t\tif (code === 'ERR_MODULE_NOT_FOUND' || code === 'ERR_LOAD_URL') {\n\t\t\t\t// Only ignore the error if it's about the config file itself\n\t\t\t\t// not being found, not about other imports in the config file\n\t\t\t\tif (msg.match(/ec\\.config\\.mjs.*(imported from|resolved id)/)) continue\n\t\t\t}\n\t\t\t// If the config file exists, but there was a problem loading it, rethrow the error\n\t\t\tthrow new Error(\n\t\t\t\t`Your project includes an Expressive Code config file (\"ec.config.mjs\")\n\t\t\t\tthat could not be loaded due to ${code ? `the error ${code}` : 'the following error'}: ${msg}`.replace(/\\s+/g, ' '),\n\t\t\t\terror instanceof Error ? { cause: error } : undefined\n\t\t\t)\n\t\t}\n\t}\n\treturn {}\n}\n","import { RemarkExpressiveCodeRenderer, createRenderer, getStableObjectHash } from 'remark-expressive-code'\nimport { AstroExpressiveCodeOptions } from './ec-config'\nimport { PartialAstroConfig, ConfigSetupHookArgs, getAssetsBaseHref } from './astro-config'\n\nexport type CreateAstroRendererArgs = {\n\tecConfig: AstroExpressiveCodeOptions\n\tastroConfig: PartialAstroConfig\n\tlogger?: ConfigSetupHookArgs['logger'] | undefined\n}\n\nexport type AstroExpressiveCodeRenderer = RemarkExpressiveCodeRenderer & {\n\thashedStyles: [string, string][]\n\thashedScripts: [string, string][]\n}\n\nexport async function createAstroRenderer({ ecConfig, astroConfig, logger }: CreateAstroRendererArgs): Promise<AstroExpressiveCodeRenderer> {\n\t// Process the merged options and apply defaults\n\tconst { emitExternalStylesheet = true, customCreateRenderer, plugins = [], shiki = true, ...rest } = ecConfig ?? {}\n\n\t// Determine the assets directory and href prefix from the Astro config\n\tconst assetsDir = astroConfig.build?.assets || '_astro'\n\n\t// Add a plugin that inserts external references to the styles and scripts\n\t// that would normally be inlined into the first code block of every page\n\tconst hashedStyles: [string, string][] = []\n\tconst hashedScripts: [string, string][] = []\n\tplugins.push({\n\t\tname: 'astro-expressive-code',\n\t\thooks: {\n\t\t\tpostprocessRenderedBlockGroup: ({ renderData, renderedGroupContents }) => {\n\t\t\t\t// Only continue if this is the first code block group of the page\n\t\t\t\tconst isFirstGroupInDocument = renderedGroupContents[0]?.codeBlock.parentDocument?.positionInDocument?.groupIndex === 0\n\t\t\t\tif (!isFirstGroupInDocument) return\n\n\t\t\t\ttype HastElement = Extract<(typeof renderData.groupAst.children)[number], { type: 'element' }>\n\t\t\t\tconst extraElements: HastElement[] = []\n\n\t\t\t\t// Add hashed stylesheet links\n\t\t\t\thashedStyles.forEach(([hashedRoute]) => {\n\t\t\t\t\textraElements.push({\n\t\t\t\t\t\ttype: 'element',\n\t\t\t\t\t\ttagName: 'link',\n\t\t\t\t\t\tproperties: { rel: 'stylesheet', href: `${getAssetsBaseHref('.css', astroConfig.build?.assetsPrefix, astroConfig.base)}${hashedRoute}` },\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\t// Add hashed script module links for all JS modules\n\t\t\t\thashedScripts.forEach(([hashedRoute]) => {\n\t\t\t\t\textraElements.push({\n\t\t\t\t\t\ttype: 'element',\n\t\t\t\t\t\ttagName: 'script',\n\t\t\t\t\t\tproperties: { type: 'module', src: `${getAssetsBaseHref('.js', astroConfig.build?.assetsPrefix, astroConfig.base)}${hashedRoute}` },\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tif (!extraElements.length) return\n\t\t\t\trenderData.groupAst.children.unshift(...extraElements)\n\t\t\t},\n\t\t},\n\t})\n\n\t// Unless Shiki was disabled, merge any supported Shiki settings\n\t// from the Astro config into the plugin options\n\tconst mergedShikiConfig = shiki === true ? {} : shiki\n\tif (mergedShikiConfig && !mergedShikiConfig.langs && astroConfig.markdown?.shikiConfig?.langs) {\n\t\tmergedShikiConfig.langs = astroConfig.markdown.shikiConfig.langs as NonNullable<typeof mergedShikiConfig.langs>\n\t}\n\n\t// Create the renderer\n\tconst renderer = (await (customCreateRenderer ?? createRenderer)({\n\t\tplugins,\n\t\tlogger,\n\t\tshiki: mergedShikiConfig,\n\t\t...rest,\n\t})) as AstroExpressiveCodeRenderer\n\trenderer.hashedStyles = hashedStyles\n\trenderer.hashedScripts = hashedScripts\n\n\t// Unless disabled, move the base and theme styles from the inline renderer\n\t// into an external CSS file that can be cached by browsers\n\tif (emitExternalStylesheet) {\n\t\tconst combinedStyles = `${renderer.baseStyles}${renderer.themeStyles}`\n\t\thashedStyles.push(getHashedRouteWithContent(combinedStyles, `/${assetsDir}/ec.{hash}.css`))\n\t\trenderer.baseStyles = ''\n\t\trenderer.themeStyles = ''\n\t}\n\n\t// Also move any JS modules into external files\n\t// (this is always enabled because the alternative using `injectScript`\n\t// does not allow omitting the scripts on pages without any code blocks)\n\tconst uniqueJsModules = [...new Set<string>(renderer.jsModules)]\n\trenderer.jsModules = []\n\thashedScripts.push(...uniqueJsModules.map((moduleCode) => getHashedRouteWithContent(moduleCode, `/${assetsDir}/ec.{hash}.js`)))\n\n\treturn renderer\n}\n\n/**\n * Generates a hashed route and content tuple for a given content string.\n */\nfunction getHashedRouteWithContent(content: string, routeTemplate: string): [string, string] {\n\tconst contentHash = getStableObjectHash(content, { hashLength: 5 })\n\treturn [routeTemplate.replace('{hash}', contentHash), content]\n}\n","import type { AstroIntegration } from 'astro'\n\n// As the arguments of the `astro:config:setup` hook are incompatible between Astro versions,\n// we just access this type internally and accept `unknown` args externally to prevent\n// version-specific types from being included in the build output\nexport type ConfigSetupHookArgs = Parameters<NonNullable<AstroIntegration['hooks']['astro:config:setup']>>[0]\n\n/**\n * Contains the parts of the Astro config that are used by this integration.\n */\nexport type PartialAstroConfig = {\n\tbase: string\n\tbuild?:\n\t\t| Partial<{\n\t\t\t\tassets: string\n\t\t\t\tassetsPrefix: AssetsPrefix\n\t\t  }>\n\t\t| undefined\n\tmarkdown?:\n\t\t| Partial<{\n\t\t\t\tshikiConfig: Partial<{\n\t\t\t\t\tlangs: ConfigSetupHookArgs['config']['markdown']['shikiConfig']['langs']\n\t\t\t\t}>\n\t\t  }>\n\t\t| undefined\n\troot: URL | string\n\tsrcDir: URL\n}\n\ntype AssetsPrefix =\n\t| string\n\t| ({\n\t\t\tfallback: string\n\t  } & Record<string, string>)\n\t| undefined\n\nexport function serializePartialAstroConfig(config: PartialAstroConfig): string {\n\tconst partialConfig: PartialAstroConfig = {\n\t\tbase: config.base,\n\t\troot: config.root,\n\t\tsrcDir: config.srcDir,\n\t}\n\tif (config.build) {\n\t\tpartialConfig.build = {}\n\t\tif (config.build.assets) partialConfig.build.assets = config.build.assets\n\t\tif (config.build.assetsPrefix) partialConfig.build.assetsPrefix = config.build.assetsPrefix\n\t}\n\tif (config.markdown?.shikiConfig?.langs) {\n\t\tpartialConfig.markdown = { shikiConfig: { langs: config.markdown.shikiConfig.langs } }\n\t}\n\treturn JSON.stringify(partialConfig)\n}\n\nfunction getAssetsPrefix(fileExtension: string, assetsPrefix?: AssetsPrefix): string {\n\tif (!assetsPrefix) return ''\n\tif (typeof assetsPrefix === 'string') return assetsPrefix\n\t// we assume the file extension has a leading '.' and we remove it\n\tconst dotLessFileExtension = fileExtension.slice(1)\n\tif (assetsPrefix[dotLessFileExtension]) {\n\t\treturn assetsPrefix[dotLessFileExtension]\n\t}\n\treturn assetsPrefix.fallback\n}\n\n/**\n * Returns the base URL href for assets with the given file extension (e.g. `.js`).\n *\n * The returned value does not include a trailing slash.\n */\nexport function getAssetsBaseHref(fileExtension: string, assetsPrefix: AssetsPrefix | undefined, base: string | undefined): string {\n\treturn (getAssetsPrefix(fileExtension, assetsPrefix) || base || '').trim().replace(/\\/+$/g, '')\n}\n","import { fileURLToPath } from 'node:url'\nimport type { ViteUserConfig } from 'astro'\nimport { stableStringify } from 'remark-expressive-code'\nimport { findEcConfigFilePath } from './ec-config'\nimport { PartialAstroConfig, serializePartialAstroConfig } from './astro-config'\nimport { AstroExpressiveCodeOptions } from './ec-config'\n\n/**\n * This Vite plugin provides access to page-wide styles & scripts that the Astro integration\n * extracted from its `RemarkExpressiveCodeRenderer`. We extract these contents from the renderer\n * to prevent the remark plugin from repeatedly injecting them into the HTML output of every page\n * while still allowing pages to load them on demand if they contain code blocks.\n *\n * All data is provided as virtual modules under the `virtual:astro-expressive-code/*` namespace,\n * which can be used by injected routes to generate CSS & JS files.\n */\nexport function vitePluginAstroExpressiveCode({\n\tstyles,\n\tscripts,\n\tecIntegrationOptions,\n\tastroConfig,\n}: {\n\tstyles: [string, string][]\n\tscripts: [string, string][]\n\tecIntegrationOptions: AstroExpressiveCodeOptions\n\tastroConfig: PartialAstroConfig\n}): NonNullable<ViteUserConfig['plugins']>[number] {\n\t// Map virtual module names to their code contents as strings\n\tconst modules: Record<string, string> = {\n\t\t'virtual:astro-expressive-code/scripts': `export const scripts = ${JSON.stringify(scripts)}`,\n\t\t'virtual:astro-expressive-code/styles': `export const styles = ${JSON.stringify(styles)}`,\n\t}\n\n\t// Create virtual config module\n\tconst configModuleContents: string[] = []\n\t// - Partial Astro config\n\tconfigModuleContents.push(`export const astroConfig = ${serializePartialAstroConfig(astroConfig)}`)\n\t// - Expressive Code integration options\n\tconst { customConfigPreprocessors, ...otherEcIntegrationOptions } = ecIntegrationOptions\n\tconfigModuleContents.push(`export const ecIntegrationOptions = ${stableStringify(otherEcIntegrationOptions)}`)\n\t// - Expressive Code config file options\n\tconst ecConfigFilePath = findEcConfigFilePath(astroConfig.root)\n\tif (ecConfigFilePath) {\n\t\tconst strEcConfigFilePath = JSON.stringify(ecConfigFilePath)\n\t\tconfigModuleContents.push(\n\t\t\t`let ecConfigFileOptions = {}`,\n\t\t\t`try {`,\n\t\t\t`\tecConfigFileOptions = (await import(${strEcConfigFilePath})).default`,\n\t\t\t`} catch (e) {`,\n\t\t\t`\tconsole.error('*** Failed to load Expressive Code config file ${strEcConfigFilePath}. You can ignore this message if you just renamed/removed the file.\\\\n\\\\n(Full error message: \"' + (e?.message || e) + '\")\\\\n')`,\n\t\t\t`}`,\n\t\t\t`export { ecConfigFileOptions }`\n\t\t)\n\t} else {\n\t\tconfigModuleContents.push(`export const ecConfigFileOptions = {}`)\n\t}\n\tmodules['virtual:astro-expressive-code/config'] = configModuleContents.join('\\n')\n\n\t// Create virtual config preprocessor module\n\tmodules['virtual:astro-expressive-code/preprocess-config'] = customConfigPreprocessors?.preprocessComponentConfig || `export default ({ ecConfig }) => ecConfig`\n\n\treturn {\n\t\tname: 'vite-plugin-astro-expressive-code',\n\t\tresolveId: (id) => {\n\t\t\t// Resolve virtual API module to the current package entrypoint\n\t\t\tif (id === 'virtual:astro-expressive-code/api') return fileURLToPath(import.meta.url)\n\t\t\t// Resolve other virtual modules\n\t\t\treturn id in modules ? `\\0${id}` : undefined\n\t\t},\n\t\tload: (id) => (id?.[0] === '\\0' ? modules[id.slice(1)] : undefined),\n\t}\n}\n"],"mappings":"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","names":["fileURLToPath","fileURLToPath","integration"]}