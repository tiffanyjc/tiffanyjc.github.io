// src/index.ts
import remarkExpressiveCode from "remark-expressive-code";

// src/ec-config.ts
import { existsSync } from "node:fs";
import { resolve } from "node:path";
import { fileURLToPath } from "node:url";
function getSupportedEcConfigFilePaths(projectRootUrl) {
  const projectRootPath = fileURLToPath(projectRootUrl);
  return [resolve(projectRootPath, "ec.config.mjs")];
}
function findEcConfigFilePath(projectRootUrl) {
  const ecConfigFile = getSupportedEcConfigFilePaths(projectRootUrl).find((fileName) => existsSync(fileName));
  return ecConfigFile;
}
async function loadEcConfigFile(projectRootUrl) {
  const pathsToTry = [
    // This path works in most scenarios, but not when the integration is processed by Vite
    // due to a Vite bug affecting import URLs using the "file:" protocol
    new URL(`./ec.config.mjs?t=${Date.now()}`, projectRootUrl).href
  ];
  if (import.meta.env?.BASE_URL?.length) {
    pathsToTry.push(`/ec.config.mjs?t=${Date.now()}`);
  }
  for (const path of pathsToTry) {
    try {
      const module = await import(
        /* @vite-ignore */
        path
      );
      if (!module.default) {
        throw new Error(`Missing or invalid default export. Please export your Expressive Code config object as the default export.`);
      }
      return module.default;
    } catch (error) {
      const msg = error instanceof Error ? error.message : error;
      const code = error.code;
      if (code === "ERR_MODULE_NOT_FOUND" || code === "ERR_LOAD_URL") {
        if (msg.match(/ec\.config\.mjs.*(imported from|resolved id)/))
          continue;
      }
      throw new Error(
        `Your project includes an Expressive Code config file ("ec.config.mjs")
				that could not be loaded due to ${code ? `the error ${code}` : "the following error"}: ${msg}`.replace(/\s+/g, " "),
        error instanceof Error ? { cause: error } : void 0
      );
    }
  }
  return {};
}

// src/renderer.ts
import { createRenderer, getStableObjectHash } from "remark-expressive-code";

// src/astro-config.ts
function serializePartialAstroConfig(config) {
  const partialConfig = {
    base: config.base,
    root: config.root,
    srcDir: config.srcDir
  };
  if (config.build) {
    partialConfig.build = {};
    if (config.build.assets)
      partialConfig.build.assets = config.build.assets;
    if (config.build.assetsPrefix)
      partialConfig.build.assetsPrefix = config.build.assetsPrefix;
  }
  if (config.markdown?.shikiConfig?.langs) {
    partialConfig.markdown = { shikiConfig: { langs: config.markdown.shikiConfig.langs } };
  }
  return JSON.stringify(partialConfig);
}
function getAssetsPrefix(fileExtension, assetsPrefix) {
  if (!assetsPrefix)
    return "";
  if (typeof assetsPrefix === "string")
    return assetsPrefix;
  const dotLessFileExtension = fileExtension.slice(1);
  if (assetsPrefix[dotLessFileExtension]) {
    return assetsPrefix[dotLessFileExtension];
  }
  return assetsPrefix.fallback;
}
function getAssetsBaseHref(fileExtension, assetsPrefix, base) {
  return (getAssetsPrefix(fileExtension, assetsPrefix) || base || "").trim().replace(/\/+$/g, "");
}

// src/renderer.ts
async function createAstroRenderer({ ecConfig, astroConfig, logger }) {
  const { emitExternalStylesheet = true, customCreateRenderer, plugins = [], shiki = true, ...rest } = ecConfig ?? {};
  const assetsDir = astroConfig.build?.assets || "_astro";
  const hashedStyles = [];
  const hashedScripts = [];
  plugins.push({
    name: "astro-expressive-code",
    hooks: {
      postprocessRenderedBlockGroup: ({ renderData, renderedGroupContents }) => {
        const isFirstGroupInDocument = renderedGroupContents[0]?.codeBlock.parentDocument?.positionInDocument?.groupIndex === 0;
        if (!isFirstGroupInDocument)
          return;
        const extraElements = [];
        hashedStyles.forEach(([hashedRoute]) => {
          extraElements.push({
            type: "element",
            tagName: "link",
            properties: { rel: "stylesheet", href: `${getAssetsBaseHref(".css", astroConfig.build?.assetsPrefix, astroConfig.base)}${hashedRoute}` },
            children: []
          });
        });
        hashedScripts.forEach(([hashedRoute]) => {
          extraElements.push({
            type: "element",
            tagName: "script",
            properties: { type: "module", src: `${getAssetsBaseHref(".js", astroConfig.build?.assetsPrefix, astroConfig.base)}${hashedRoute}` },
            children: []
          });
        });
        if (!extraElements.length)
          return;
        renderData.groupAst.children.unshift(...extraElements);
      }
    }
  });
  const mergedShikiConfig = shiki === true ? {} : shiki;
  if (mergedShikiConfig && !mergedShikiConfig.langs && astroConfig.markdown?.shikiConfig?.langs) {
    mergedShikiConfig.langs = astroConfig.markdown.shikiConfig.langs;
  }
  const renderer = await (customCreateRenderer ?? createRenderer)({
    plugins,
    logger,
    shiki: mergedShikiConfig,
    ...rest
  });
  renderer.hashedStyles = hashedStyles;
  renderer.hashedScripts = hashedScripts;
  if (emitExternalStylesheet) {
    const combinedStyles = `${renderer.baseStyles}${renderer.themeStyles}`;
    hashedStyles.push(getHashedRouteWithContent(combinedStyles, `/${assetsDir}/ec.{hash}.css`));
    renderer.baseStyles = "";
    renderer.themeStyles = "";
  }
  const uniqueJsModules = [...new Set(renderer.jsModules)];
  renderer.jsModules = [];
  hashedScripts.push(...uniqueJsModules.map((moduleCode) => getHashedRouteWithContent(moduleCode, `/${assetsDir}/ec.{hash}.js`)));
  return renderer;
}
function getHashedRouteWithContent(content, routeTemplate) {
  const contentHash = getStableObjectHash(content, { hashLength: 5 });
  return [routeTemplate.replace("{hash}", contentHash), content];
}

// src/vite-plugin.ts
import { fileURLToPath as fileURLToPath2 } from "node:url";
import { stableStringify } from "remark-expressive-code";
function vitePluginAstroExpressiveCode({
  styles,
  scripts,
  ecIntegrationOptions,
  astroConfig
}) {
  const modules = {
    "virtual:astro-expressive-code/scripts": `export const scripts = ${JSON.stringify(scripts)}`,
    "virtual:astro-expressive-code/styles": `export const styles = ${JSON.stringify(styles)}`
  };
  const configModuleContents = [];
  configModuleContents.push(`export const astroConfig = ${serializePartialAstroConfig(astroConfig)}`);
  const { customConfigPreprocessors, ...otherEcIntegrationOptions } = ecIntegrationOptions;
  configModuleContents.push(`export const ecIntegrationOptions = ${stableStringify(otherEcIntegrationOptions)}`);
  const ecConfigFilePath = findEcConfigFilePath(astroConfig.root);
  if (ecConfigFilePath) {
    const strEcConfigFilePath = JSON.stringify(ecConfigFilePath);
    configModuleContents.push(
      `let ecConfigFileOptions = {}`,
      `try {`,
      `	ecConfigFileOptions = (await import(${strEcConfigFilePath})).default`,
      `} catch (e) {`,
      `	console.error('*** Failed to load Expressive Code config file ${strEcConfigFilePath}. You can ignore this message if you just renamed/removed the file.\\n\\n(Full error message: "' + (e?.message || e) + '")\\n')`,
      `}`,
      `export { ecConfigFileOptions }`
    );
  } else {
    configModuleContents.push(`export const ecConfigFileOptions = {}`);
  }
  modules["virtual:astro-expressive-code/config"] = configModuleContents.join("\n");
  modules["virtual:astro-expressive-code/preprocess-config"] = customConfigPreprocessors?.preprocessComponentConfig || `export default ({ ecConfig }) => ecConfig`;
  return {
    name: "vite-plugin-astro-expressive-code",
    resolveId: (id) => {
      if (id === "virtual:astro-expressive-code/api")
        return fileURLToPath2(import.meta.url);
      return id in modules ? `\0${id}` : void 0;
    },
    load: (id) => id?.[0] === "\0" ? modules[id.slice(1)] : void 0
  };
}

// src/index.ts
export * from "remark-expressive-code";
function astroExpressiveCode(integrationOptions = {}) {
  const integration = {
    name: "astro-expressive-code",
    hooks: {
      "astro:config:setup": async (args) => {
        const { config: astroConfig, updateConfig, injectRoute, logger, addWatchFile } = args;
        const ownPosition = astroConfig.integrations.findIndex((integration2) => integration2.name === "astro-expressive-code");
        const mdxPosition = astroConfig.integrations.findIndex((integration2) => integration2.name === "@astrojs/mdx");
        if (ownPosition > -1 && mdxPosition > -1 && mdxPosition < ownPosition) {
          throw new Error(
            `Incorrect integration order: To allow code blocks on MDX pages to use
						astro-expressive-code, please move astroExpressiveCode() before mdx()
						in the "integrations" array of your Astro config file.`.replace(/\s+/g, " ")
          );
        }
        getSupportedEcConfigFilePaths(astroConfig.root).forEach((filePath) => addWatchFile(filePath));
        const ecConfigFileOptions = await loadEcConfigFile(astroConfig.root);
        const mergedOptions = { ...ecConfigFileOptions, ...integrationOptions };
        const forwardedIntegrationOptions = { ...integrationOptions };
        delete forwardedIntegrationOptions.customConfigPreprocessors;
        if (Object.keys(ecConfigFileOptions).length > 0 && Object.keys(forwardedIntegrationOptions).length > 0) {
          logger.warn(
            `Your project includes an Expressive Code config file ("ec.config.mjs"),
						but your Astro config file also contains Expressive Code options.
						To avoid unexpected results from merging multiple config sources,
						move all Expressive Code options into its config file.
						Found options: ${Object.keys(forwardedIntegrationOptions).join(", ")}`.replace(/\s+/g, " ")
          );
        }
        const processedEcConfig = await mergedOptions.customConfigPreprocessors?.preprocessAstroIntegrationConfig({ ecConfig: mergedOptions, astroConfig }) || mergedOptions;
        const { customCreateAstroRenderer } = processedEcConfig;
        delete processedEcConfig.customCreateAstroRenderer;
        delete processedEcConfig.customConfigPreprocessors;
        const { hashedStyles, hashedScripts, ...renderer } = await (customCreateAstroRenderer ?? createAstroRenderer)({ astroConfig, ecConfig: processedEcConfig, logger });
        hashedStyles.forEach(([hashedRoute]) => {
          const entrypoint = new URL("../routes/styles.ts", import.meta.url).href;
          injectRoute({
            pattern: hashedRoute,
            entrypoint,
            prerender: true,
            // @ts-expect-error: Also provide the old property name used in Astro 3
            entryPoint: entrypoint
          });
        });
        hashedScripts.forEach(([hashedRoute]) => {
          const entrypoint = new URL("../routes/scripts.ts", import.meta.url).href;
          injectRoute({
            pattern: hashedRoute,
            entrypoint,
            prerender: true,
            // @ts-expect-error: Also provide the old property name used in Astro 3
            entryPoint: entrypoint
          });
        });
        const remarkExpressiveCodeOptions = {
          // Even though we have created a custom renderer, some options are used
          // by the remark integration itself (e.g. `tabWidth`, `getBlockLocale`),
          // so we pass all of them through just to be safe
          ...processedEcConfig,
          // Pass our custom renderer to the remark integration
          customCreateRenderer: () => renderer
        };
        updateConfig({
          vite: {
            plugins: [
              // Add the Vite plugin that provides all data for the route handler
              vitePluginAstroExpressiveCode({
                styles: hashedStyles,
                scripts: hashedScripts,
                ecIntegrationOptions: integrationOptions,
                astroConfig
              })
            ]
          },
          markdown: {
            syntaxHighlight: false,
            remarkPlugins: [[remarkExpressiveCode, remarkExpressiveCodeOptions]]
          }
        });
      }
    }
  };
  return integration;
}
function defineEcConfig(config) {
  return config;
}
var src_default = astroExpressiveCode;
export {
  astroExpressiveCode,
  createAstroRenderer,
  src_default as default,
  defineEcConfig
};
//# sourceMappingURL=index.js.map